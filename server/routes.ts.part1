import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth } from "./auth";
import { z } from "zod";
import { insertIdeaSchema, updateLeanCanvasSchema, webhookResponseSchema, insertProjectDocumentSchema, updateProjectDocumentSchema, DocumentType } from "@shared/schema";
import { fetchLeanCanvasData, fetchUserIdeas, fetchBusinessRequirements, fetchFunctionalRequirements } from "./supabase";
import { emailService } from "./email";
import { generateVerificationToken, generateTokenExpiry, buildVerificationUrl } from "./utils/auth-utils";

function isAuthenticated(req: Request, res: Response, next: NextFunction) {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ message: "Unauthorized" });
}

export async function registerRoutes(app: Express): Promise<Server> {
  // sets up /api/register, /api/login, /api/logout, /api/user
  setupAuth(app);

  // Ideas routes
  app.get("/api/ideas", isAuthenticated, async (req, res, next) => {
    try {
      const userId = req.user!.id;
      console.log(`[SECURITY] User ${userId} requesting all their ideas`);
      
      // Get the user's ideas with proper filtering
      const ideas = await storage.getIdeasByUser(userId);
      
      // Add an extra layer of security - double-check each idea belongs to this user
      const verifiedIdeas = ideas.filter(idea => {
        if (idea.userId !== userId) {
          console.log(`[CRITICAL SECURITY VIOLATION] Idea ${idea.id} with userId ${idea.userId} was about to be sent to user ${userId}`);
          return false;
        }
        return true;
      });
      
      console.log(`[SECURITY] Returning ${verifiedIdeas.length} verified ideas to user ${userId}`);
      
      // Return only the verified ideas
      res.json(verifiedIdeas);
    } catch (error) {
      console.error('[SECURITY ERROR] Error retrieving ideas:', error);
      next(error);
    }
  });

  app.post("/api/ideas", isAuthenticated, async (req, res, next) => {
    try {
      // Extract and validate the base idea fields
      const validatedIdeaData = insertIdeaSchema.parse(req.body);
      
      // Create the idea
      const idea = await storage.createIdea({
        ...validatedIdeaData,
        userId: req.user!.id,
      });
      
      // Check if lean canvas data was submitted
      if (req.body.leanCanvas) {
        try {
          // Create the lean canvas
          await storage.createLeanCanvas({
            ideaId: idea.id,
            problem: req.body.leanCanvas.problem || null,
            customerSegments: req.body.leanCanvas.customerSegments || null,
            uniqueValueProposition: req.body.leanCanvas.uniqueValueProposition || null,
            solution: req.body.leanCanvas.solution || null,
            channels: req.body.leanCanvas.channels || null,
            revenueStreams: req.body.leanCanvas.revenueStreams || null,
            costStructure: req.body.leanCanvas.costStructure || null,
            keyMetrics: req.body.leanCanvas.keyMetrics || null,
            unfairAdvantage: req.body.leanCanvas.unfairAdvantage || null,
          });
          
          // Update the idea status to Completed if there's canvas data
          if (Object.values(req.body.leanCanvas).some(val => val)) {
            await storage.updateIdeaStatus(idea.id, "Completed");
          }
        } catch (canvasError) {
          console.error("Error creating lean canvas:", canvasError);
          // We don't fail the entire request if canvas creation fails
          // Just log the error and continue
        }
      }
      
      res.status(201).json(idea);
    } catch (error) {
      next(error);
    }
  });

  app.get("/api/ideas/:id", isAuthenticated, async (req, res, next) => {
    try {
      const ideaId = parseInt(req.params.id);
      const userId = req.user!.id;
      
      console.log(`[SECURITY] User ${userId} attempting to access idea ${ideaId}`);
      
      // Pass userId to getIdeaById for security check - this ensures the user can only access their own ideas
      const idea = await storage.getIdeaById(ideaId, userId);
      
      if (!idea) {
        console.log(`[SECURITY] Idea ${ideaId} not found or unauthorized access`);
        return res.status(404).json({ message: "Idea not found" });
      }
      
      console.log(`[SECURITY] Authorized access: User ${userId} accessing their idea ${ideaId}`);
      res.json(idea);
    } catch (error) {
      next(error);
    }
  });

  app.patch("/api/ideas/:id", isAuthenticated, async (req, res, next) => {
    try {
      const ideaId = parseInt(req.params.id);
      const idea = await storage.getIdeaById(ideaId);
      
      if (!idea) {
        return res.status(404).json({ message: "Idea not found" });
      }
      
      if (idea.userId !== req.user!.id) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Only allow updating specific fields
      const allowedFields = ['title', 'idea', 'companyName', 'companyStage', 'founderName', 'founderEmail', 'websiteUrl'];
      const updates: Record<string, any> = {};
      
      for (const field of allowedFields) {
        if (field in req.body) {
          updates[field] = req.body[field];
        }
      }
      
      // Update the idea
      if (Object.keys(updates).length > 0) {
        await storage.updateIdea(ideaId, updates);
        const updatedIdea = await storage.getIdeaById(ideaId);
        res.json(updatedIdea);
      } else {
        res.status(400).json({ message: "No valid fields to update" });
      }
    } catch (error) {
      next(error);
    }
  });

  // Generate Business Requirements Document for an idea
  // Functional Requirements Document generation API
  app.post("/api/ideas/:id/generate-functional-requirements", isAuthenticated, async (req, res, next) => {
    try {
      const ideaId = parseInt(req.params.id);
      const userId = req.user!.id;
      const { instructions, projectId, prdId, brdId, leancanvasId } = req.body;
      
      console.log(`[FUNCTIONAL REQUIREMENTS] User ${userId} requesting functional requirements generation for idea ${ideaId}`);
      console.log(`[FUNCTIONAL REQUIREMENTS] Payload: projectId=${projectId}, prdId=${prdId}, brdId=${brdId}, leancanvasId=${leancanvasId}`);
      
      // Verify the idea exists and belongs to the user
      const idea = await storage.getIdeaById(ideaId, userId);
      if (!idea) {
        return res.status(404).json({ error: "Idea not found or you don't have access to it" });
      }
      
      // Check if a functional requirements document already exists
      const existingDoc = await storage.getDocumentByType(ideaId, 'FunctionalRequirements');
      if (existingDoc) {
        return res.status(409).json({ 
          error: 'Functional requirements document already exists', 
          document: existingDoc 
        });
      }
      
      // Get webhook URL and auth from environment
      const webhookUrl = process.env.N8N_FUNCTIONAL_WEBHOOK_URL;
      if (!webhookUrl) {
        console.error('[FUNCTIONAL REQUIREMENTS] Missing N8N_FUNCTIONAL_WEBHOOK_URL environment variable');
        return res.status(500).json({ error: 'Webhook URL is not configured' });
      }
      
      // Setup basic auth if credentials are available
      let authHeader = '';
      if (process.env.N8N_AUTH_USERNAME && process.env.N8N_AUTH_PASSWORD) {
        const auth = Buffer.from(`${process.env.N8N_AUTH_USERNAME}:${process.env.N8N_AUTH_PASSWORD}`).toString('base64');
        authHeader = `Basic ${auth}`;
        console.log('[FUNCTIONAL REQUIREMENTS] Using basic auth for webhook');
      } else {
        console.log('[FUNCTIONAL REQUIREMENTS] No auth credentials found for webhook');
      }
      
      // Step 1: Create the document with Generating status
      const document = await storage.createDocument({
        ideaId,
        title: "Functional Requirements Document",
        documentType: "FunctionalRequirements",
        status: "Generating",
        generationStartedAt: new Date()
      });
      
      console.log(`[FUNCTIONAL REQUIREMENTS] Created document with ID ${document.id}`);
      
      // Step 2: Collect and verify the IDs for related documents
      let supabaseProjId = projectId || null;
      let supabaseLeanCanvasId = leancanvasId || null;
      let supapbasePrdId = prdId || null;
      let supapbaseBrdId = brdId || null;
      
      // If IDs weren't provided in the request, try to get them from the canvas
      if (!supabaseProjId || !supabaseLeanCanvasId) {
        try {
          const canvas = await storage.getLeanCanvasByIdeaId(ideaId, userId);
          if (canvas) {
            if (!supabaseProjId && canvas.projectId) {
              supabaseProjId = canvas.projectId;
            }
            if (!supabaseLeanCanvasId && canvas.leancanvasId) {
              supabaseLeanCanvasId = canvas.leancanvasId;
            }
            console.log(`[FUNCTIONAL REQUIREMENTS] Found project ID ${supabaseProjId} and canvas ID ${supabaseLeanCanvasId} from local database`);
          }
        } catch (canvasError) {
          console.error('[FUNCTIONAL REQUIREMENTS] Error getting lean canvas data:', canvasError);
        }
      }
      
      // If PRD ID not provided, try to get from existing document
      if (!supapbasePrdId) {
        try {
          const prdDoc = await storage.getDocumentByType(ideaId, 'ProjectRequirements');
          if (prdDoc && prdDoc.externalId) {
            supapbasePrdId = prdDoc.externalId;
            console.log(`[FUNCTIONAL REQUIREMENTS] Using PRD external ID: ${supapbasePrdId}`);
          }
        } catch (prdError) {
          console.error('[FUNCTIONAL REQUIREMENTS] Error getting PRD document:', prdError);
        }
      }
      
      // If BRD ID not provided, try to get from existing document
      if (!supapbaseBrdId) {
        try {
          const brdDoc = await storage.getDocumentByType(ideaId, 'BusinessRequirements');
          if (brdDoc && brdDoc.externalId) {
            supapbaseBrdId = brdDoc.externalId;
            console.log(`[FUNCTIONAL REQUIREMENTS] Using BRD external ID: ${supapbaseBrdId}`);
          }
        } catch (brdError) {
          console.error('[FUNCTIONAL REQUIREMENTS] Error getting BRD document:', brdError);
        }
      }
      
      // Make sure we have valid values and not undefined/null
      supabaseProjId = supabaseProjId || ideaId.toString();
      
      console.log(`[FUNCTIONAL REQUIREMENTS] Sending request to n8n with project_id=${supabaseProjId}, leancanvas_id=${supabaseLeanCanvasId || 'not available'}`);
      console.log(`[FUNCTIONAL REQUIREMENTS] Using webhook URL: ${webhookUrl}`);
      console.log(`[FUNCTIONAL REQUIREMENTS] With instructions: ${instructions || "No specific instructions"}`);
      
      // Build the payload for the webhook
      const payload = {
        project_id: supabaseProjId,
        leancanvas_id: supabaseLeanCanvasId,
        prd_id: supapbasePrdId,
        brd_id: supapbaseBrdId,
        instructions: instructions || "Generate comprehensive functional requirements based on the previous documents."
      };
      
      console.log(`[FUNCTIONAL REQUIREMENTS] Sending webhook with payload:`, payload);
      
      // Call the n8n webhook
      try {
        const webhookResponse = await fetch(webhookUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": authHeader
          },
          body: JSON.stringify(payload)
        });
        
        if (!webhookResponse.ok) {
          const errorText = await webhookResponse.text();
          console.error(`[FUNCTIONAL REQUIREMENTS] Failed to call webhook: ${webhookResponse.status} ${errorText}`);
          
          res.status(200).json({ 
            message: "Functional requirements document created, but webhook failed. Document will remain in Generating state until timeout.",
            document,
            webhookError: errorText
          });
          return;
        }
        
        // Get webhook response
        const webhookResponseText = await webhookResponse.text();
        console.log(`[FUNCTIONAL REQUIREMENTS] N8N webhook response: ${webhookResponseText}`);
        
        try {
          // Try to parse response as JSON if possible
          const responseData = JSON.parse(webhookResponseText);
          console.log('[FUNCTIONAL REQUIREMENTS] Parsed webhook response:', responseData);
          
          // Extract the ID from the response if available
          const externalId = responseData.id || responseData.functionalId || responseData.frd_id;
          
          if (externalId) {
            // Update the document with the external ID
            await storage.updateDocument(document.id, {
              externalId: externalId
            });
            
            console.log(`[FUNCTIONAL REQUIREMENTS] Updated document with external ID: ${externalId}`);
            
            res.status(200).json({
              message: "Functional requirements generation started",
              document: {...document, externalId},
              webhookResponse: responseData
            });
          } else {
            console.warn('[FUNCTIONAL REQUIREMENTS] No external ID found in webhook response');
            res.status(200).json({
              message: "Functional requirements generation started but no ID was received",
              document: document,
              webhookResponse: responseData
            });
          }
        } catch (parseError) {
          console.warn('[FUNCTIONAL REQUIREMENTS] Could not parse webhook response as JSON:', parseError);
          res.status(200).json({
            message: "Functional requirements generation started but response format unexpected",
            document: document,
            webhookResponseText: webhookResponseText
          });
        }
      } catch (fetchError) {
        console.error('[FUNCTIONAL REQUIREMENTS] Error making webhook request:', fetchError);
        res.status(200).json({
          message: "Functional requirements document created, but webhook request failed. Document will remain in Generating state until timeout.",
          document,
          error: fetchError.message
        });
      }
    } catch (error) {
      console.error("Error generating functional requirements:", error);
      next(error);
    }
